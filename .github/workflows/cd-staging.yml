name: CD - Staging (auto after CI)

on:
  workflow_run:
    workflows: ["CI - Test & Push (testing)"]
    types: [completed]

permissions:
  contents: read
  id-token: write

env:
  # Deploy the exact images built in Stage-1:
  IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  LOCATION: australiaeast   # change if you prefer another region

jobs:
  staging:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'testing' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (for k8s assets if needed)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Derive names
        id: names
        shell: bash
        run: |
          SHORT_SHA="${IMAGE_TAG:0:7}"
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "RG=rg-stg-$SHORT_SHA"   >> $GITHUB_OUTPUT
          echo "AKS=aks-stg-$SHORT_SHA" >> $GITHUB_OUTPUT
          echo "NS=stg-$SHORT_SHA"      >> $GITHUB_OUTPUT

      - name: Get ACR name & id
        id: acr
        shell: bash
        run: |
          ACR_NAME="${ACR_LOGIN_SERVER%%.*}"
          echo "ACR_NAME=$ACR_NAME" >> $GITHUB_OUTPUT
          ACR_ID=$(az acr show -n "$ACR_NAME" --query id -o tsv)
          echo "ACR_ID=$ACR_ID" >> $GITHUB_OUTPUT

      - name: Create RG + AKS (ephemeral)
        shell: bash
        run: |
          az group create -n "${{ steps.names.outputs.RG }}" -l "${{ env.LOCATION }}"
          az aks create \
            -g "${{ steps.names.outputs.RG }}" \
            -n "${{ steps.names.outputs.AKS }}" \
            -l "${{ env.LOCATION }}" \
            --node-count 1 \
            --enable-managed-identity \
            --attach-acr "${{ steps.acr.outputs.ACR_ID }}" \
            --generate-ssh-keys

      - name: Get kubeconfig
        shell: bash
        run: |
          az aks get-credentials -g "${{ steps.names.outputs.RG }}" -n "${{ steps.names.outputs.AKS }}" --overwrite-existing
          kubectl create namespace "${{ steps.names.outputs.NS }}"

      # --- Create minimal staging manifests that point at your ACR images (tagged with the CI commit SHA) ---
      - name: Render staging manifests
        shell: bash
        run: |
          cat > /tmp/staging.yaml <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: frontend, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: frontend } }
            template:
              metadata: { labels: { app: frontend } }
              spec:
                containers:
                - name: frontend
                  image: ${ACR}/${FRONTEND}:${TAG}
                  ports: [{ containerPort: 80 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: frontend-svc, namespace: ${NS} }
          spec:
            selector: { app: frontend }
            ports: [{ port: 80, targetPort: 80 }]
            type: ClusterIP
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: customer-service, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: customer-service } }
            template:
              metadata: { labels: { app: customer-service } }
              spec:
                containers:
                - name: customer-service
                  image: ${ACR}/${CUSTOMER}:${TAG}
                  ports: [{ containerPort: 8000 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: customer-svc, namespace: ${NS} }
          spec:
            selector: { app: customer-service }
            ports: [{ port: 8000, targetPort: 8000 }]
            type: ClusterIP
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: order-service, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: order-service } }
            template:
              metadata: { labels: { app: order-service } }
              spec:
                containers:
                - name: order-service
                  image: ${ACR}/${ORDER}:${TAG}
                  ports: [{ containerPort: 8001 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: order-svc, namespace: ${NS} }
          spec:
            selector: { app: order-service }
            ports: [{ port: 8001, targetPort: 8001 }]
            type: ClusterIP
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: product-service, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: product-service } }
            template:
              metadata: { labels: { app: product-service } }
              spec:
                containers:
                - name: product-service
                  image: ${ACR}/${PRODUCT}:${TAG}
                  ports: [{ containerPort: 8002 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: product-svc, namespace: ${NS} }
          spec:
            selector: { app: product-service }
            ports: [{ port: 8002, targetPort: 8002 }]
            type: ClusterIP
          YAML

          # Substitute variables
          export NS="${{ steps.names.outputs.NS }}"
          export ACR="${{ env.ACR_LOGIN_SERVER }}"
          export FRONTEND="frontend"
          export CUSTOMER="customer_service"
          export ORDER="order_service"
          export PRODUCT="product_service"
          export TAG="${{ env.IMAGE_TAG }}"
          envsubst < /tmp/staging.yaml > /tmp/staging.rendered.yaml
          echo "---- Rendered ----"
          cat /tmp/staging.rendered.yaml

      - name: Deploy to staging
        shell: bash
        run: |
          kubectl apply -f /tmp/staging.rendered.yaml

      - name: Wait for pods (rollout)
        shell: bash
        run: |
          NS="${{ steps.names.outputs.NS }}"
          for d in frontend customer-service order-service product-service; do
            kubectl rollout status deployment/$d -n "$NS" --timeout=180s
          done

      # ---- Simple acceptance test (internal) ----
      - name: Acceptance test (curl inside cluster)
        shell: bash
        run: |
          NS="${{ steps.names.outputs.NS }}"
          # curl frontend service for HTTP 200
          kubectl run curl --rm -i -n "$NS" --image=curlimages/curl --restart=Never -- \
            sh -c "curl -s -o /dev/null -w '%{http_code}' http://frontend-svc" | tee /tmp/http.txt
          code=$(cat /tmp/http.txt | tail -n1)
          echo "HTTP code: $code"
          if [ "$code" != "200" ] && [ "$code" != "301" ] && [ "$code" != "302" ]; then
            echo "Acceptance test failed"; exit 1
          fi

      # ---- Always destroy the temporary environment ----
      - name: Tear down staging RG (destroy everything)
        if: always()
        shell: bash
        run: |
          az group delete -n "${{ steps.names.outputs.RG }}" --yes --no-wait
