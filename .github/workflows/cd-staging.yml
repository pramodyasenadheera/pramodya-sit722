name: CD - Staging (ephemeral namespace on existing AKS)

on:
  # auto-run after CI on branch 'testing'
  workflow_run:
    workflows: ["CI - Test & Push (testing)"]
    types: [completed]
  workflow_dispatch: {}

permissions:
  contents: read
  id-token: write

env:
  IMAGE_TAG:        ${{ github.event.workflow_run.head_sha || github.sha }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  STG_RG:           week10d-rg
  STG_AKS:          week10d-aks
  STG_NS_PREFIX:    stg

jobs:
  staging:
    if: >
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'workflow_run' &&
       github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.head_branch == 'testing')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Derive ephemeral namespace
        id: names
        shell: bash
        run: |
          SHORT="${IMAGE_TAG:0:7}"
          echo "NS=${{ env.STG_NS_PREFIX }}-$SHORT" >> $GITHUB_OUTPUT

      - name: Get kubeconfig & create namespace
        shell: bash
        run: |
          az aks get-credentials -g "${{ env.STG_RG }}" -n "${{ env.STG_AKS }}" --overwrite-existing
          kubectl create namespace "${{ steps.names.outputs.NS }}" || true

      - name: Render manifests
        shell: bash
        run: |
          NS="${{ steps.names.outputs.NS }}"
          ACR="${{ env.ACR_LOGIN_SERVER }}"
          TAG="${{ env.IMAGE_TAG }}"
          cat > /tmp/staging.yaml <<'YAML'
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: frontend, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: frontend } }
            template:
              metadata: { labels: { app: frontend } }
              spec:
                containers:
                - name: frontend
                  image: ${ACR}/frontend:${TAG}
                  ports: [{ containerPort: 80 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: frontend-svc, namespace: ${NS} }
          spec:
            selector: { app: frontend }
            ports: [{ port: 80, targetPort: 80 }]
            type: ClusterIP
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: customer-service, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: customer-service } }
            template:
              metadata: { labels: { app: customer-service } }
              spec:
                containers:
                - name: customer-service
                  image: ${ACR}/customer_service:${TAG}
                  ports: [{ containerPort: 8000 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: customer-svc, namespace: ${NS} }
          spec:
            selector: { app: customer-service }
            ports: [{ port: 8000, targetPort: 8000 }]
            type: ClusterIP
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: order-service, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: order-service } }
            template:
              metadata: { labels: { app: order-service } }
              spec:
                containers:
                - name: order-service
                  image: ${ACR}/order_service:${TAG}
                  ports: [{ containerPort: 8001 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: order-svc, namespace: ${NS} }
          spec:
            selector: { app: order-service }
            ports: [{ port: 8001, targetPort: 8001 }]
            type: ClusterIP
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata: { name: product-service, namespace: ${NS} }
          spec:
            replicas: 1
            selector: { matchLabels: { app: product-service } }
            template:
              metadata: { labels: { app: product-service } }
              spec:
                containers:
                - name: product-service
                  image: ${ACR}/product_service:${TAG}
                  ports: [{ containerPort: 8002 }]
          ---
          apiVersion: v1
          kind: Service
          metadata: { name: product-svc, namespace: ${NS} }
          spec:
            selector: { app: product-service }
            ports: [{ port: 8002, targetPort: 8002 }]
            type: ClusterIP
          YAML
          # substitute variables
          sed -i "s|\${NS}|$NS|g; s|\${ACR}|$ACR|g; s|\${TAG}|$TAG|g" /tmp/staging.yaml
          cat /tmp/staging.yaml

      - name: Deploy
        run: kubectl apply -f /tmp/staging.yaml

      - name: Wait for rollouts
        shell: bash
        run: |
          NS="${{ steps.names.outputs.NS }}"
          for d in frontend customer-service order-service product-service; do
            kubectl rollout status deployment/$d -n "$NS" --timeout=180s || true
          done

      - name: Acceptance test (in-cluster curl)
        shell: bash
        run: |
          NS="${{ steps.names.outputs.NS }}"
          kubectl run curl --rm -i -n "$NS" --image=curlimages/curl --restart=Never -- \
            sh -c "curl -s -o /dev/null -w '%{http_code}' http://frontend-svc" | tee /tmp/code.txt
          code=$(tail -n1 /tmp/code.txt)
          echo "HTTP code: $code"
          if [ "$code" != "200" ] && [ "$code" != "301" ] && [ "$code" != "302" ]; then
            echo "Acceptance test failed"; exit 1
          fi

      - name: Teardown namespace (always)
        if: always()
        run: kubectl delete ns "${{ steps.names.outputs.NS }}" --wait=false || true
